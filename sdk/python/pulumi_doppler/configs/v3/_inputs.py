# coding=utf-8
# *** WARNING: this file was generated by pulumigen. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'ChangeRequestsItemPropertiesOriginalValueTypePropertiesArgs',
    'ChangeRequestsItemPropertiesOriginalValueTypePropertiesArgsDict',
    'ChangeRequestsItemPropertiesValueTypePropertiesArgs',
    'ChangeRequestsItemPropertiesValueTypePropertiesArgsDict',
    'ChangeRequestsItemPropertiesArgs',
    'ChangeRequestsItemPropertiesArgsDict',
    'SecretsPropertiesAlgoliaPropertiesArgs',
    'SecretsPropertiesAlgoliaPropertiesArgsDict',
    'SecretsPropertiesDatabasePropertiesArgs',
    'SecretsPropertiesDatabasePropertiesArgsDict',
    'SecretsPropertiesStripePropertiesArgs',
    'SecretsPropertiesStripePropertiesArgsDict',
    'SecretsPropertiesArgs',
    'SecretsPropertiesArgsDict',
]

MYPY = False

if not MYPY:
    class ChangeRequestsItemPropertiesOriginalValueTypePropertiesArgsDict(TypedDict):
        """
        The valueType you expect the secret to have before `valueType` is applied. If specified, the request will only be processed if the provided valueType matches what's found in Doppler.
        """
        type: NotRequired[pulumi.Input['ChangeRequestsItemPropertiesOriginalValueTypePropertiesType']]
elif False:
    ChangeRequestsItemPropertiesOriginalValueTypePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChangeRequestsItemPropertiesOriginalValueTypePropertiesArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['ChangeRequestsItemPropertiesOriginalValueTypePropertiesType']] = None):
        """
        The valueType you expect the secret to have before `valueType` is applied. If specified, the request will only be processed if the provided valueType matches what's found in Doppler.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ChangeRequestsItemPropertiesOriginalValueTypePropertiesType']]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ChangeRequestsItemPropertiesOriginalValueTypePropertiesType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ChangeRequestsItemPropertiesValueTypePropertiesArgsDict(TypedDict):
        """
        The default valueType (string) will result in no validations being applied.
        """
        type: NotRequired[pulumi.Input['ChangeRequestsItemPropertiesValueTypePropertiesType']]
elif False:
    ChangeRequestsItemPropertiesValueTypePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChangeRequestsItemPropertiesValueTypePropertiesArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['ChangeRequestsItemPropertiesValueTypePropertiesType']] = None):
        """
        The default valueType (string) will result in no validations being applied.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ChangeRequestsItemPropertiesValueTypePropertiesType']]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ChangeRequestsItemPropertiesValueTypePropertiesType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ChangeRequestsItemPropertiesArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the secret.
        """
        original_name: pulumi.Input[str]
        """
        The original name of the secret. Use `null` (an actual `null`, not the string `null`) or omit this parameter for new secrets. If it differs from `name` then a rename is inferred.
        """
        value: pulumi.Input[str]
        """
        The value the secret should have. Use `null` (an actual `null`, not the string `null`) to leave the existing secret value unchanged.
        """
        original_value: NotRequired[pulumi.Input[str]]
        """
        The value you expect the secret to have before `name` is applied. If specified, the request will only be processed if the provided value matches what's found in Doppler.
        """
        original_value_type: NotRequired[pulumi.Input['ChangeRequestsItemPropertiesOriginalValueTypePropertiesArgsDict']]
        """
        The valueType you expect the secret to have before `valueType` is applied. If specified, the request will only be processed if the provided valueType matches what's found in Doppler.
        """
        original_visibility: NotRequired[pulumi.Input[str]]
        """
        Must be set to either `masked`, `unmasked`, or `restricted`. The visibility you expect the secret to have before `visibility` is applied. If specified, the request will only be processed if the provided visibility matches what's found in Doppler.
        """
        should_converge: NotRequired[pulumi.Input[bool]]
        """
        Defaults to `false`. Can only be set to `true` if the config being updated is a branch config and there is a secret with the same name in the root config. In this case, the branch secret will inherit the value and visibility type from the root secret.
        """
        should_delete: NotRequired[pulumi.Input[bool]]
        """
        Defaults to `false`. If set to `true`, will delete the secret matching the `name` field.
        """
        should_promote: NotRequired[pulumi.Input[bool]]
        """
        Defaults to `false`. Can only be set to `true` if the config being updated is a branch config. If set to `true`, the provided secret will be set in both the branch config as well as the root config in that environment.
        """
        value_type: NotRequired[pulumi.Input['ChangeRequestsItemPropertiesValueTypePropertiesArgsDict']]
        """
        The default valueType (string) will result in no validations being applied.
        """
        visibility: NotRequired[pulumi.Input[str]]
        """
        Must be set to either `masked`, `unmasked`, or `restricted`.
        """
elif False:
    ChangeRequestsItemPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChangeRequestsItemPropertiesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 original_name: pulumi.Input[str],
                 value: pulumi.Input[str],
                 original_value: Optional[pulumi.Input[str]] = None,
                 original_value_type: Optional[pulumi.Input['ChangeRequestsItemPropertiesOriginalValueTypePropertiesArgs']] = None,
                 original_visibility: Optional[pulumi.Input[str]] = None,
                 should_converge: Optional[pulumi.Input[bool]] = None,
                 should_delete: Optional[pulumi.Input[bool]] = None,
                 should_promote: Optional[pulumi.Input[bool]] = None,
                 value_type: Optional[pulumi.Input['ChangeRequestsItemPropertiesValueTypePropertiesArgs']] = None,
                 visibility: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the secret.
        :param pulumi.Input[str] original_name: The original name of the secret. Use `null` (an actual `null`, not the string `null`) or omit this parameter for new secrets. If it differs from `name` then a rename is inferred.
        :param pulumi.Input[str] value: The value the secret should have. Use `null` (an actual `null`, not the string `null`) to leave the existing secret value unchanged.
        :param pulumi.Input[str] original_value: The value you expect the secret to have before `name` is applied. If specified, the request will only be processed if the provided value matches what's found in Doppler.
        :param pulumi.Input['ChangeRequestsItemPropertiesOriginalValueTypePropertiesArgs'] original_value_type: The valueType you expect the secret to have before `valueType` is applied. If specified, the request will only be processed if the provided valueType matches what's found in Doppler.
        :param pulumi.Input[str] original_visibility: Must be set to either `masked`, `unmasked`, or `restricted`. The visibility you expect the secret to have before `visibility` is applied. If specified, the request will only be processed if the provided visibility matches what's found in Doppler.
        :param pulumi.Input[bool] should_converge: Defaults to `false`. Can only be set to `true` if the config being updated is a branch config and there is a secret with the same name in the root config. In this case, the branch secret will inherit the value and visibility type from the root secret.
        :param pulumi.Input[bool] should_delete: Defaults to `false`. If set to `true`, will delete the secret matching the `name` field.
        :param pulumi.Input[bool] should_promote: Defaults to `false`. Can only be set to `true` if the config being updated is a branch config. If set to `true`, the provided secret will be set in both the branch config as well as the root config in that environment.
        :param pulumi.Input['ChangeRequestsItemPropertiesValueTypePropertiesArgs'] value_type: The default valueType (string) will result in no validations being applied.
        :param pulumi.Input[str] visibility: Must be set to either `masked`, `unmasked`, or `restricted`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "original_name", original_name)
        pulumi.set(__self__, "value", value)
        if original_value is not None:
            pulumi.set(__self__, "original_value", original_value)
        if original_value_type is not None:
            pulumi.set(__self__, "original_value_type", original_value_type)
        if original_visibility is not None:
            pulumi.set(__self__, "original_visibility", original_visibility)
        if should_converge is not None:
            pulumi.set(__self__, "should_converge", should_converge)
        if should_delete is not None:
            pulumi.set(__self__, "should_delete", should_delete)
        if should_promote is not None:
            pulumi.set(__self__, "should_promote", should_promote)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the secret.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="originalName")
    def original_name(self) -> pulumi.Input[str]:
        """
        The original name of the secret. Use `null` (an actual `null`, not the string `null`) or omit this parameter for new secrets. If it differs from `name` then a rename is inferred.
        """
        return pulumi.get(self, "original_name")

    @original_name.setter
    def original_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "original_name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value the secret should have. Use `null` (an actual `null`, not the string `null`) to leave the existing secret value unchanged.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="originalValue")
    def original_value(self) -> Optional[pulumi.Input[str]]:
        """
        The value you expect the secret to have before `name` is applied. If specified, the request will only be processed if the provided value matches what's found in Doppler.
        """
        return pulumi.get(self, "original_value")

    @original_value.setter
    def original_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "original_value", value)

    @property
    @pulumi.getter(name="originalValueType")
    def original_value_type(self) -> Optional[pulumi.Input['ChangeRequestsItemPropertiesOriginalValueTypePropertiesArgs']]:
        """
        The valueType you expect the secret to have before `valueType` is applied. If specified, the request will only be processed if the provided valueType matches what's found in Doppler.
        """
        return pulumi.get(self, "original_value_type")

    @original_value_type.setter
    def original_value_type(self, value: Optional[pulumi.Input['ChangeRequestsItemPropertiesOriginalValueTypePropertiesArgs']]):
        pulumi.set(self, "original_value_type", value)

    @property
    @pulumi.getter(name="originalVisibility")
    def original_visibility(self) -> Optional[pulumi.Input[str]]:
        """
        Must be set to either `masked`, `unmasked`, or `restricted`. The visibility you expect the secret to have before `visibility` is applied. If specified, the request will only be processed if the provided visibility matches what's found in Doppler.
        """
        return pulumi.get(self, "original_visibility")

    @original_visibility.setter
    def original_visibility(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "original_visibility", value)

    @property
    @pulumi.getter(name="shouldConverge")
    def should_converge(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`. Can only be set to `true` if the config being updated is a branch config and there is a secret with the same name in the root config. In this case, the branch secret will inherit the value and visibility type from the root secret.
        """
        return pulumi.get(self, "should_converge")

    @should_converge.setter
    def should_converge(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_converge", value)

    @property
    @pulumi.getter(name="shouldDelete")
    def should_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`. If set to `true`, will delete the secret matching the `name` field.
        """
        return pulumi.get(self, "should_delete")

    @should_delete.setter
    def should_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_delete", value)

    @property
    @pulumi.getter(name="shouldPromote")
    def should_promote(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`. Can only be set to `true` if the config being updated is a branch config. If set to `true`, the provided secret will be set in both the branch config as well as the root config in that environment.
        """
        return pulumi.get(self, "should_promote")

    @should_promote.setter
    def should_promote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_promote", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[pulumi.Input['ChangeRequestsItemPropertiesValueTypePropertiesArgs']]:
        """
        The default valueType (string) will result in no validations being applied.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: Optional[pulumi.Input['ChangeRequestsItemPropertiesValueTypePropertiesArgs']]):
        pulumi.set(self, "value_type", value)

    @property
    @pulumi.getter
    def visibility(self) -> Optional[pulumi.Input[str]]:
        """
        Must be set to either `masked`, `unmasked`, or `restricted`.
        """
        return pulumi.get(self, "visibility")

    @visibility.setter
    def visibility(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "visibility", value)


if not MYPY:
    class SecretsPropertiesAlgoliaPropertiesArgsDict(TypedDict):
        computed: NotRequired[pulumi.Input[str]]
        note: NotRequired[pulumi.Input[str]]
        raw: NotRequired[pulumi.Input[str]]
elif False:
    SecretsPropertiesAlgoliaPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretsPropertiesAlgoliaPropertiesArgs:
    def __init__(__self__, *,
                 computed: Optional[pulumi.Input[str]] = None,
                 note: Optional[pulumi.Input[str]] = None,
                 raw: Optional[pulumi.Input[str]] = None):
        if computed is not None:
            pulumi.set(__self__, "computed", computed)
        if note is not None:
            pulumi.set(__self__, "note", note)
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def computed(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "computed")

    @computed.setter
    def computed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "computed", value)

    @property
    @pulumi.getter
    def note(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "note")

    @note.setter
    def note(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "note", value)

    @property
    @pulumi.getter
    def raw(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "raw")

    @raw.setter
    def raw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw", value)


if not MYPY:
    class SecretsPropertiesDatabasePropertiesArgsDict(TypedDict):
        computed: NotRequired[pulumi.Input[str]]
        note: NotRequired[pulumi.Input[str]]
        raw: NotRequired[pulumi.Input[str]]
elif False:
    SecretsPropertiesDatabasePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretsPropertiesDatabasePropertiesArgs:
    def __init__(__self__, *,
                 computed: Optional[pulumi.Input[str]] = None,
                 note: Optional[pulumi.Input[str]] = None,
                 raw: Optional[pulumi.Input[str]] = None):
        if computed is not None:
            pulumi.set(__self__, "computed", computed)
        if note is not None:
            pulumi.set(__self__, "note", note)
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def computed(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "computed")

    @computed.setter
    def computed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "computed", value)

    @property
    @pulumi.getter
    def note(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "note")

    @note.setter
    def note(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "note", value)

    @property
    @pulumi.getter
    def raw(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "raw")

    @raw.setter
    def raw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw", value)


if not MYPY:
    class SecretsPropertiesStripePropertiesArgsDict(TypedDict):
        computed: NotRequired[pulumi.Input[str]]
        note: NotRequired[pulumi.Input[str]]
        raw: NotRequired[pulumi.Input[str]]
elif False:
    SecretsPropertiesStripePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretsPropertiesStripePropertiesArgs:
    def __init__(__self__, *,
                 computed: Optional[pulumi.Input[str]] = None,
                 note: Optional[pulumi.Input[str]] = None,
                 raw: Optional[pulumi.Input[str]] = None):
        if computed is not None:
            pulumi.set(__self__, "computed", computed)
        if note is not None:
            pulumi.set(__self__, "note", note)
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def computed(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "computed")

    @computed.setter
    def computed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "computed", value)

    @property
    @pulumi.getter
    def note(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "note")

    @note.setter
    def note(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "note", value)

    @property
    @pulumi.getter
    def raw(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "raw")

    @raw.setter
    def raw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw", value)


if not MYPY:
    class SecretsPropertiesArgsDict(TypedDict):
        algolia: NotRequired[pulumi.Input['SecretsPropertiesAlgoliaPropertiesArgsDict']]
        database: NotRequired[pulumi.Input['SecretsPropertiesDatabasePropertiesArgsDict']]
        stripe: NotRequired[pulumi.Input['SecretsPropertiesStripePropertiesArgsDict']]
elif False:
    SecretsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretsPropertiesArgs:
    def __init__(__self__, *,
                 algolia: Optional[pulumi.Input['SecretsPropertiesAlgoliaPropertiesArgs']] = None,
                 database: Optional[pulumi.Input['SecretsPropertiesDatabasePropertiesArgs']] = None,
                 stripe: Optional[pulumi.Input['SecretsPropertiesStripePropertiesArgs']] = None):
        if algolia is not None:
            pulumi.set(__self__, "algolia", algolia)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if stripe is not None:
            pulumi.set(__self__, "stripe", stripe)

    @property
    @pulumi.getter
    def algolia(self) -> Optional[pulumi.Input['SecretsPropertiesAlgoliaPropertiesArgs']]:
        return pulumi.get(self, "algolia")

    @algolia.setter
    def algolia(self, value: Optional[pulumi.Input['SecretsPropertiesAlgoliaPropertiesArgs']]):
        pulumi.set(self, "algolia", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input['SecretsPropertiesDatabasePropertiesArgs']]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input['SecretsPropertiesDatabasePropertiesArgs']]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def stripe(self) -> Optional[pulumi.Input['SecretsPropertiesStripePropertiesArgs']]:
        return pulumi.get(self, "stripe")

    @stripe.setter
    def stripe(self, value: Optional[pulumi.Input['SecretsPropertiesStripePropertiesArgs']]):
        pulumi.set(self, "stripe", value)


